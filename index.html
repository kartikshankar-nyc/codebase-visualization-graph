<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codebase Visualizer</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- D3.js for network visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- PapaParse for CSV export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        :root {
            --primary-color: #4361ee;
            --secondary-color: #3a0ca3;
            --accent-color: #7209b7;
            --success-color: #4cc9f0;
            --warning-color: #f72585;
            --light-bg: #f8f9fa;
            --dark-bg: #212529;
            
            /* Color codes for dependency types */
            --import-color: #4cc9f0;
            --call-color: #4361ee;
            --extend-color: #7209b7;
            --reference-color: #f72585;
            --define-color: #3a0ca3;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            background-color: var(--light-bg);
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background-color: var(--dark-bg);
            color: white;
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        .content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .file-tree {
            width: 30%;
            overflow: auto;
            padding: 1rem;
            background-color: #fff;
            border-right: 1px solid #ddd;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
            transition: width 0.3s ease-in-out;
        }

        .file-tree.collapsed {
            width: 50px;
            padding: 0;
            overflow: hidden;
        }

        .graph-container {
            flex: 1;
            overflow: hidden;
            background-color: var(--light-bg);
            position: relative;
        }

        #network-graph {
            width: 100%;
            height: 100%;
            background-color: #f8f9fa;
        }

        .tree-node {
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .tree-node:hover {
            background-color: #f0f0f0;
        }

        .folder {
            color: var(--secondary-color);
            font-weight: bold;
        }

        .file {
            color: var(--primary-color);
            margin-left: 15px;
        }

        .file-icon {
            margin-right: 5px;
        }

        .tooltip {
            position: absolute;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 300px;
            z-index: 100;
        }

        .badge {
            margin-right: 5px;
            margin-bottom: 5px;
        }

        /* Collapse button styles */
        .collapse-button {
            position: absolute;
            top: 50%;
            left: 30%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10;
            transition: left 0.3s ease-in-out;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .collapse-button.collapsed {
            left: 50px;
        }

        .collapse-button:hover {
            background-color: var(--secondary-color);
        }

        .collapse-button i {
            transition: transform 0.3s;
        }

        .collapse-button.collapsed i {
            transform: rotate(180deg);
        }

        /* Collapsed tree styles */
        .file-tree-collapsed-content {
            display: none;
            flex-direction: column;
            align-items: center;
            padding-top: 10px;
            height: 100%;
        }

        .file-tree.collapsed .file-tree-collapsed-content {
            display: flex;
        }

        .file-tree.collapsed #fileTree {
            display: none;
        }

        .vertical-text {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            text-align: center;
            margin-top: 20px;
            color: var(--primary-color);
            font-weight: bold;
        }
        
        /* Graph legend */
        .dependency-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        /* Zoom buttons */
        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .zoom-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: white;
            border: 1px solid #ddd;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .zoom-button:hover {
            background-color: #f0f0f0;
        }
        
        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }

        .spinner-border {
            width: 3rem;
            height: 3rem;
            color: var(--primary-color);
        }

        .hidden {
            display: none;
        }

        .node {
            fill: var(--primary-color);
            stroke: #fff;
            stroke-width: 2px;
            cursor: pointer;
        }

        .link {
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }

        .node text {
            pointer-events: none;
            font-size: 10px;
            fill: #333;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="container-fluid">
                <div class="row">
                    <div class="col">
                        <h1>Codebase Visualizer</h1>
                    </div>
                    <div class="col-auto">
                        <button id="centerGraphBtn" class="btn btn-outline-light me-2">
                            <i class="bi bi-bullseye"></i> Center Graph
                        </button>
                        <input type="file" id="folderInput" webkitdirectory directory multiple class="d-none">
                        <button id="browseButton" class="btn btn-primary">
                            <i class="bi bi-folder"></i> Browse Files
                        </button>
                        <button id="exportButton" class="btn btn-success ms-2" disabled>
                            <i class="bi bi-download"></i> Export Dependencies (CSV)
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <main class="content">
            <section class="file-tree" id="fileTreeContainer">
                <div id="fileTree">
                    <div class="alert alert-info">
                        Please select a folder to start visualization.
                    </div>
                </div>
                <div class="file-tree-collapsed-content">
                    <i class="bi bi-folder-fill" style="font-size: 24px; color: var(--secondary-color);"></i>
                    <div class="vertical-text">File Tree</div>
                </div>
            </section>
            
            <button id="collapseButton" class="collapse-button">
                <i class="bi bi-chevron-left"></i>
            </button>

            <section class="graph-container">
                <div id="network-graph"></div>
                
                <div class="zoom-controls">
                    <button id="zoomInBtn" class="zoom-button">
                        <i class="bi bi-plus"></i>
                    </button>
                    <button id="zoomOutBtn" class="zoom-button">
                        <i class="bi bi-dash"></i>
                    </button>
                </div>
                
                <div class="dependency-legend">
                    <h6>Dependency Types:</h6>
                    <div>
                        <span class="badge" style="background-color: var(--call-color)">Calls</span>
                        <span class="badge" style="background-color: var(--import-color)">Imports/Requires</span>
                        <span class="badge" style="background-color: var(--extend-color)">Extends/Inherits</span>
                        <span class="badge" style="background-color: var(--reference-color)">References</span>
                        <span class="badge" style="background-color: var(--define-color)">Defines</span>
                    </div>
                </div>
                
                <div id="tooltip" class="tooltip"></div>
                <div id="loadingOverlay" class="loading-overlay hidden">
                    <div class="spinner-border" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-3">Processing files... This may take a while for large codebases.</p>
                    <div class="progress mt-2" style="width: 50%;">
                        <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Bootstrap JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">

    <script>
        // Global variables to store application state
        let files = [];
        let dependencies = [];
        let fileTree = {};
        let selectedFolder = null;
        let simulation = null;
        let zoomBehavior = null;
        
        // DOM elements
        const browseButton = document.getElementById('browseButton');
        const folderInput = document.getElementById('folderInput');
        const fileTreeElement = document.getElementById('fileTree');
        const fileTreeContainer = document.getElementById('fileTreeContainer');
        const collapseButton = document.getElementById('collapseButton');
        const exportButton = document.getElementById('exportButton');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const progressBar = document.getElementById('progressBar');
        const networkGraph = document.getElementById('network-graph');
        const tooltip = document.getElementById('tooltip');
        const centerGraphBtn = document.getElementById('centerGraphBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        
        // Graph configuration
        const graphConfig = {
            nodeSize: 10,
            showLabels: true
        };
        
        // Initialize the application
        function init() {
            // Set up event listeners
            browseButton.addEventListener('click', () => folderInput.click());
            folderInput.addEventListener('change', handleFolderSelection);
            exportButton.addEventListener('click', exportDependencies);
            
            // File tree collapse functionality
            collapseButton.addEventListener('click', toggleFileTree);
            
            // Graph control event listeners
            centerGraphBtn.addEventListener('click', centerGraph);
            zoomInBtn.addEventListener('click', zoomIn);
            zoomOutBtn.addEventListener('click', zoomOut);
            
            // Initialize an empty graph
            initializeGraph();
        }
        
        // Toggle file tree collapsed state
        function toggleFileTree() {
            fileTreeContainer.classList.toggle('collapsed');
            collapseButton.classList.toggle('collapsed');
            
            // Update simulation center after collapsing
            if (simulation) {
                simulation
                    .force('center', d3.forceCenter(
                        networkGraph.clientWidth / 2,
                        networkGraph.clientHeight / 2
                    ))
                    .alpha(0.3)
                    .restart();
            }
        }
        
        // Handle folder selection from the input
        function handleFolderSelection(event) {
            const selectedFiles = Array.from(event.target.files);
            
            if (selectedFiles.length === 0) return;
            
            // Show loading overlay
            loadingOverlay.classList.remove('hidden');
            progressBar.style.width = '0%';
            
            // Get the base folder
            const firstFilePath = selectedFiles[0].webkitRelativePath;
            const baseFolderName = firstFilePath.split('/')[0];
            selectedFolder = baseFolderName;
            
            // Reset variables
            files = [];
            dependencies = [];
            fileTree = { name: baseFolderName, type: 'folder', children: [] };
            
            // Process files in batches to avoid UI freezing
            processFilesInBatches(selectedFiles, 0);
        }
        
        // Process files in batches to keep the UI responsive
        function processFilesInBatches(selectedFiles, startIndex, batchSize = 100) {
            const endIndex = Math.min(startIndex + batchSize, selectedFiles.length);
            const batch = selectedFiles.slice(startIndex, endIndex);
            
            // Update progress
            const progress = Math.floor((endIndex / selectedFiles.length) * 100);
            progressBar.style.width = `${progress}%`;
            
            // Process batch
            batch.forEach(file => {
                const path = file.webkitRelativePath;
                files.push({ path, file });
                addToFileTree(fileTree, path.split('/').slice(1), file);
            });
            
            if (endIndex < selectedFiles.length) {
                // Continue with next batch
                setTimeout(() => {
                    processFilesInBatches(selectedFiles, endIndex, batchSize);
                }, 0);
            } else {
                // All files processed, build dependencies
                buildDependencies().then(() => {
                    renderFileTree();
                    updateGraph();
                    
                    // Enable export button
                    exportButton.removeAttribute('disabled');
                    
                    // Hide loading overlay
                    loadingOverlay.classList.add('hidden');
                });
            }
        }
        
        // Add a file to the file tree structure
        function addToFileTree(node, pathParts, file) {
            if (pathParts.length === 0) return;
            
            const currentPart = pathParts[0];
            const remainingParts = pathParts.slice(1);
            
            // Find existing child
            let child = node.children.find(c => c.name === currentPart);
            
            if (!child) {
                // Determine if it's a file or folder
                const isFile = pathParts.length === 1;
                child = {
                    name: currentPart,
                    type: isFile ? 'file' : 'folder',
                    children: [],
                    parent: node
                };
                
                if (isFile) {
                    child.file = file;
                    child.ext = currentPart.includes('.') ? 
                        currentPart.split('.').pop().toLowerCase() : '';
                }
                
                node.children.push(child);
            }
            
            if (remainingParts.length > 0) {
                addToFileTree(child, remainingParts, file);
            }
        }
        
        // Render the file tree in the UI
        function renderFileTree() {
            fileTreeElement.innerHTML = '';
            
            const createNodeElement = (node, level = 0) => {
                const div = document.createElement('div');
                div.className = `tree-node ${node.type}`;
                div.style.paddingLeft = `${level * 15}px`;
                
                // Icon based on type
                let icon = '';
                if (node.type === 'folder') {
                    icon = '<i class="bi bi-folder-fill file-icon"></i>';
                } else {
                    // Choose icon based on file extension
                    switch (node.ext) {
                        case 'js':
                            icon = '<i class="bi bi-filetype-js file-icon"></i>';
                            break;
                        case 'html':
                            icon = '<i class="bi bi-filetype-html file-icon"></i>';
                            break;
                        case 'css':
                            icon = '<i class="bi bi-filetype-css file-icon"></i>';
                            break;
                        case 'json':
                            icon = '<i class="bi bi-filetype-json file-icon"></i>';
                            break;
                        case 'md':
                            icon = '<i class="bi bi-markdown-fill file-icon"></i>';
                            break;
                        default:
                            icon = '<i class="bi bi-file-earmark-text file-icon"></i>';
                    }
                }
                
                div.innerHTML = `${icon} ${node.name}`;
                
                // Add click handler
                if (node.type === 'folder') {
                    div.addEventListener('click', () => {
                        // Toggle visibility of children
                        const childContainer = div.nextElementSibling;
                        if (childContainer) {
                            childContainer.classList.toggle('hidden');
                            // Toggle folder icon
                            const icon = div.querySelector('.bi');
                            if (icon.classList.contains('bi-folder-fill')) {
                                icon.classList.replace('bi-folder-fill', 'bi-folder2-open');
                            } else {
                                icon.classList.replace('bi-folder2-open', 'bi-folder-fill');
                            }
                        }
                    });
                } else {
                    // If file, highlight in the graph
                    div.addEventListener('click', () => {
                        highlightNodeInGraph(node.name);
                    });
                }
                
                return div;
            };
            
            const renderNode = (node, container, level = 0) => {
                const nodeElement = createNodeElement(node, level);
                container.appendChild(nodeElement);
                
                if (node.children && node.children.length > 0) {
                    const childContainer = document.createElement('div');
                    childContainer.className = node.type === 'folder' ? 'child-container' : '';
                    childContainer.style.paddingLeft = '15px';
                    
                    // Sort children: folders first, then files
                    const sortedChildren = [...node.children].sort((a, b) => {
                        if (a.type === b.type) {
                            return a.name.localeCompare(b.name);
                        }
                        return a.type === 'folder' ? -1 : 1;
                    });
                    
                    sortedChildren.forEach(child => {
                        renderNode(child, childContainer, level + 1);
                    });
                    
                    container.appendChild(childContainer);
                }
            };
            
            renderNode(fileTree, fileTreeElement);
        }
        
        // Build dependency relationships between files
        async function buildDependencies() {
            const textFiles = files.filter(f => {
                const ext = f.path.split('.').pop().toLowerCase();
                return ['js', 'jsx', 'ts', 'tsx', 'py', 'java', 'c', 'cpp', 'cs', 'php', 'rb', 'go', 'html', 'css'].includes(ext);
            });
            
            // Process each file to extract dependencies
            for (let i = 0; i < textFiles.length; i++) {
                const file = textFiles[i];
                try {
                    const content = await readFileContent(file.file);
                    const deps = extractDependencies(file.path, content);
                    dependencies.push(...deps);
                } catch (error) {
                    console.error(`Error processing file ${file.path}:`, error);
                }
                
                // Update progress bar for dependencies extraction
                const progress = Math.floor((i / textFiles.length) * 100);
                progressBar.style.width = `${progress}%`;
            }
            
            return dependencies;
        }
        
        // Read file content
        function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(e);
                reader.readAsText(file);
            });
        }
        
        // Extract dependencies from file content
        function extractDependencies(filePath, content) {
            const filename = filePath.split('/').pop();
            const ext = filename.split('.').pop().toLowerCase();
            const extractedDeps = [];
            
            // Handle different file types differently
            if (['js', 'jsx', 'ts', 'tsx'].includes(ext)) {
                // JavaScript/TypeScript imports
                extractImportDependencies(filePath, content, extractedDeps);
                
                // Function calls
                extractFunctionCalls(filePath, content, extractedDeps);
                
                // Class definitions and extensions
                extractClassDependencies(filePath, content, extractedDeps);
                
                // Variable references
                extractVariableReferences(filePath, content, extractedDeps);
            } else if (['py'].includes(ext)) {
                // Python imports
                extractPythonImports(filePath, content, extractedDeps);
            } else if (['java'].includes(ext)) {
                // Java imports
                extractJavaImports(filePath, content, extractedDeps);
            } else if (['html'].includes(ext)) {
                // HTML script and link tags
                extractHtmlDependencies(filePath, content, extractedDeps);
            } else if (['css'].includes(ext)) {
                // CSS imports
                extractCssDependencies(filePath, content, extractedDeps);
            }
            
            return extractedDeps;
        }
        
        // Extract JavaScript/TypeScript imports
        function extractImportDependencies(filePath, content, dependencies) {
            // ES6 imports
            const importRegex = /import\s+(?:{([^}]+)}|\*\s+as\s+([a-zA-Z0-9_$]+)|([a-zA-Z0-9_$]+))\s+from\s+['"]([^'"]+)['"]/g;
            let match;
            
            while ((match = importRegex.exec(content)) !== null) {
                const importedItems = match[1] ? match[1].split(',').map(s => s.trim()) : [];
                const importedNamespace = match[2];
                const importedDefault = match[3];
                const importPath = match[4];
                
                // Add dependency for the import itself
                dependencies.push({
                    source: filePath,
                    target: resolveImportPath(filePath, importPath),
                    type: 'import',
                    label: 'imports'
                });
                
                // Add named imports
                if (importedItems.length > 0) {
                    importedItems.forEach(item => {
                        // Handle "as" aliases
                        const actualItem = item.split(' as ')[0].trim();
                        dependencies.push({
                            source: filePath,
                            target: resolveImportPath(filePath, importPath) + '#' + actualItem,
                            type: 'reference',
                            label: 'references'
                        });
                    });
                }
                
                // Add namespace import
                if (importedNamespace) {
                    dependencies.push({
                        source: filePath,
                        target: resolveImportPath(filePath, importPath) + '#*',
                        type: 'reference',
                        label: 'references'
                    });
                }
                
                // Add default import
                if (importedDefault) {
                    dependencies.push({
                        source: filePath,
                        target: resolveImportPath(filePath, importPath) + '#default',
                        type: 'reference',
                        label: 'references'
                    });
                }
            }
            
            // CommonJS require
            const requireRegex = /(?:const|let|var)\s+(?:{([^}]+)}|([a-zA-Z0-9_$]+))\s*=\s*require\(['"]([^'"]+)['"]\)/g;
            
            while ((match = requireRegex.exec(content)) !== null) {
                const importedItems = match[1] ? match[1].split(',').map(s => s.trim()) : [];
                const importedModule = match[2];
                const importPath = match[3];
                
                dependencies.push({
                    source: filePath,
                    target: resolveImportPath(filePath, importPath),
                    type: 'import',
                    label: 'requires'
                });
                
                if (importedItems.length > 0) {
                    importedItems.forEach(item => {
                        const actualItem = item.split(':')[0].trim();
                        dependencies.push({
                            source: filePath,
                            target: resolveImportPath(filePath, importPath) + '#' + actualItem,
                            type: 'reference',
                            label: 'references'
                        });
                    });
                }
                
                if (importedModule) {
                    dependencies.push({
                        source: filePath,
                        target: resolveImportPath(filePath, importPath) + '#*',
                        type: 'reference',
                        label: 'references'
                    });
                }
            }
        }
        
        // Extract function calls
        function extractFunctionCalls(filePath, content, dependencies) {
            // Simple function call detection
            const functionCallRegex = /(?<!['"])([a-zA-Z0-9_$]+)(?<!['"])(\.[a-zA-Z0-9_$]+)*\s*\(/g;
            let match;
            
            while ((match = functionCallRegex.exec(content)) !== null) {
                const fullMatch = match[0];
                const baseFunction = match[1];
                
                // Ignore common keywords and built-ins
                const ignoreList = ['if', 'for', 'while', 'switch', 'function', 'return', 'const', 'let', 'var', 'console'];
                if (!ignoreList.includes(baseFunction)) {
                    dependencies.push({
                        source: filePath,
                        target: `${filePath}#${baseFunction}`,
                        type: 'call',
                        label: 'calls'
                    });
                }
            }
        }
        
        // Extract class dependencies
        function extractClassDependencies(filePath, content, dependencies) {
            // Class definition
            const classDefRegex = /class\s+([a-zA-Z0-9_$]+)(?:\s+extends\s+([a-zA-Z0-9_$]+))?/g;
            let match;
            
            while ((match = classDefRegex.exec(content)) !== null) {
                const className = match[1];
                const parentClass = match[2];
                
                // Define the class
                dependencies.push({
                    source: filePath,
                    target: `${filePath}#${className}`,
                    type: 'define',
                    label: 'defines'
                });
                
                // If it extends a parent class
                if (parentClass) {
                    dependencies.push({
                        source: `${filePath}#${className}`,
                        target: `${filePath}#${parentClass}`,
                        type: 'extend',
                        label: 'extends'
                    });
                }
            }
        }
        
        // Extract variable references
        function extractVariableReferences(filePath, content, dependencies) {
            // Variable definitions
            const varDefRegex = /(?:const|let|var)\s+([a-zA-Z0-9_$]+)\s*=/g;
            let match;
            
            while ((match = varDefRegex.exec(content)) !== null) {
                const varName = match[1];
                
                dependencies.push({
                    source: filePath,
                    target: `${filePath}#${varName}`,
                    type: 'define',
                    label: 'defines'
                });
            }
        }
        
        // Extract Python imports
        function extractPythonImports(filePath, content, dependencies) {
            // import statements
            const importRegex = /import\s+([a-zA-Z0-9_$.]+)(?:\s+as\s+([a-zA-Z0-9_$]+))?/g;
            let match;
            
            while ((match = importRegex.exec(content)) !== null) {
                const module = match[1];
                
                dependencies.push({
                    source: filePath,
                    target: `${module}`,
                    type: 'import',
                    label: 'imports'
                });
            }
            
            // from ... import statements
            const fromImportRegex = /from\s+([a-zA-Z0-9_$.]+)\s+import\s+(?:([a-zA-Z0-9_$, ]+)|(\*))/g;
            
            while ((match = fromImportRegex.exec(content)) !== null) {
                const module = match[1];
                const imports = match[2] ? match[2].split(',').map(s => s.trim()) : [];
                const importAll = match[3] === '*';
                
                dependencies.push({
                    source: filePath,
                    target: `${module}`,
                    type: 'import',
                    label: 'imports'
                });
                
                if (importAll) {
                    dependencies.push({
                        source: filePath,
                        target: `${module}#*`,
                        type: 'reference',
                        label: 'references'
                    });
                } else {
                    imports.forEach(item => {
                        dependencies.push({
                            source: filePath,
                            target: `${module}#${item}`,
                            type: 'reference',
                            label: 'references'
                        });
                    });
                }
            }
        }
        
        // Extract Java imports
        function extractJavaImports(filePath, content, dependencies) {
            const importRegex = /import\s+(?:static\s+)?([a-zA-Z0-9_$.]+)(?:\.\*)?;/g;
            let match;
            
            while ((match = importRegex.exec(content)) !== null) {
                const importPath = match[1];
                
                dependencies.push({
                    source: filePath,
                    target: importPath.replace(/\./g, '/'),
                    type: 'import',
                    label: 'imports'
                });
            }
        }
        
        // Extract HTML dependencies
        function extractHtmlDependencies(filePath, content, dependencies) {
            // Script tags
            const scriptRegex = /<script(?:[^>]*src=["']([^"']+)["'][^>]*)?>(?:<\/script>)?/g;
            let match;
            
            while ((match = scriptRegex.exec(content)) !== null) {
                const src = match[1];
                if (src) {
                    dependencies.push({
                        source: filePath,
                        target: src,
                        type: 'import',
                        label: 'includes'
                    });
                }
            }
            
            // Link tags (CSS)
            const linkRegex = /<link(?:[^>]*href=["']([^"']+)["'][^>]*rel=["']stylesheet["'][^>]*|[^>]*rel=["']stylesheet["'][^>]*href=["']([^"']+)["'][^>]*)>/g;
            
            while ((match = linkRegex.exec(content)) !== null) {
                const href = match[1] || match[2];
                if (href) {
                    dependencies.push({
                        source: filePath,
                        target: href,
                        type: 'import',
                        label: 'includes'
                    });
                }
            }
        }
        
        // Extract CSS dependencies
        function extractCssDependencies(filePath, content, dependencies) {
            const importRegex = /@import\s+(?:url\()?["']([^"']+)["'](?:\))?/g;
            let match;
            
            while ((match = importRegex.exec(content)) !== null) {
                const importPath = match[1];
                
                dependencies.push({
                    source: filePath,
                    target: importPath,
                    type: 'import',
                    label: 'imports'
                });
            }
        }
        
        // Resolve relative import paths
        function resolveImportPath(sourcePath, importPath) {
            if (importPath.startsWith('.')) {
                const parts = sourcePath.split('/');
                parts.pop(); // Remove filename
                
                const importParts = importPath.split('/');
                
                importParts.forEach(part => {
                    if (part === '..') {
                        parts.pop();
                    } else if (part === '.') {
                        // Current directory, do nothing
                    } else {
                        parts.push(part);
                    }
                });
                
                return parts.join('/');
            }
            
            return importPath;
        }
        
        // Initialize the D3.js graph
        function initializeGraph() {
            // Clear previous graph
            d3.select('#network-graph').selectAll('*').remove();
            
            // Create SVG element
            const svg = d3.select('#network-graph')
                .append('svg')
                .attr('width', '100%')
                .attr('height', '100%');
            
            // Create zoom behavior
            zoomBehavior = d3.zoom()
                .scaleExtent([0.1, 3])
                .on('zoom', (event) => {
                    svg.select('g').attr('transform', event.transform);
                });
            
            // Apply zoom behavior to SVG
            svg.call(zoomBehavior);
            
            // Add container group that will be transformed
            const g = svg.append('g');
            
            // Add markers for arrows
            svg.append('defs').selectAll('marker')
                .data(['import', 'call', 'extend', 'reference', 'define', 'default'])
                .enter().append('marker')
                .attr('id', d => `arrowhead-${d}`)
                .attr('viewBox', '-0 -5 10 10')
                .attr('refX', 20)
                .attr('refY', 0)
                .attr('orient', 'auto')
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('xoverflow', 'visible')
                .append('svg:path')
                .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                .attr('fill', d => {
                    switch(d) {
                        case 'import': return 'var(--import-color)';
                        case 'call': return 'var(--call-color)';
                        case 'extend': return 'var(--extend-color)';
                        case 'reference': return 'var(--reference-color)';
                        case 'define': return 'var(--define-color)';
                        default: return '#999';
                    }
                });
            
            // Return the created SVG
            return svg;
        }
        
        // Update graph with current data
        function updateGraph() {
            // Create nodes and links from dependencies
            const nodes = new Map();
            const links = [];
            
            // Extract unique nodes
            dependencies.forEach(dep => {
                if (!nodes.has(dep.source)) {
                    nodes.set(dep.source, {
                        id: dep.source,
                        name: dep.source.split('/').pop(),
                        group: getNodeGroup(dep.source)
                    });
                }
                
                if (!nodes.has(dep.target)) {
                    nodes.set(dep.target, {
                        id: dep.target,
                        name: dep.target.split('/').pop(),
                        group: getNodeGroup(dep.target)
                    });
                }
                
                links.push({
                    source: dep.source,
                    target: dep.target,
                    type: dep.type,
                    value: 1,
                    label: dep.label
                });
            });
            
            // Convert nodes to array
            const nodesArray = Array.from(nodes.values());
            
            // Clear previous graph
            const svg = d3.select('#network-graph').select('svg');
            const g = svg.select('g');
            g.selectAll('*').remove();
            
            // Create the simulation
            simulation = d3.forceSimulation(nodesArray)
                .force('link', d3.forceLink(links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(
                    networkGraph.clientWidth / 2, 
                    networkGraph.clientHeight / 2
                ))
                .force('collision', d3.forceCollide().radius(30));
            
            // Draw links first so they appear behind nodes
            const link = g.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke', getLinkColor)
                .attr('stroke-width', 1.5)
                .attr('marker-end', d => `url(#arrowhead-${d.type || 'default'})`);
            
            // Draw nodes
            const node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('g')
                .data(nodesArray)
                .enter().append('g');
            
            // Add circles to each node
            node.append('circle')
                .attr('class', 'node')
                .attr('r', graphConfig.nodeSize)
                .attr('fill', getNodeColor)
                .on('mouseover', showNodeTooltip)
                .on('mouseout', hideTooltip)
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragging)
                    .on('end', dragEnded));
            
            // Add labels to nodes if enabled
            if (graphConfig.showLabels) {
                node.append('text')
                    .text(d => {
                        // Truncate long names
                        const name = d.name;
                        return name.length > 20 ? name.substring(0, 17) + '...' : name;
                    })
                    .attr('dx', 12)
                    .attr('dy', '.35em')
                    .style('font-size', '10px')
                    .style('fill', '#333');
            }
            
            // Update the simulation on each tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('transform', d => `translate(${d.x},${d.y})`);
            });
        }
        
        // Get node color based on file type
        function getNodeColor(d) {
            switch(d.group) {
                case 1: return '#4361ee'; // JS
                case 2: return '#3a0ca3'; // TS
                case 3: return '#7209b7'; // CSS
                case 4: return '#4cc9f0'; // HTML
                case 5: return '#f72585'; // JSON
                default: return '#6c757d'; // Others
            }
        }
        
        // Get node radius based on importance
        function getNodeRadius(d) {
            return graphConfig.nodeSize;
        }
        
        // Get link color based on relationship type
        function getLinkColor(d) {
            switch (d.type) {
                case 'import':
                    return 'var(--import-color)';
                case 'call':
                    return 'var(--call-color)';
                case 'extend':
                    return 'var(--extend-color)';
                case 'reference':
                    return 'var(--reference-color)';
                case 'define':
                    return 'var(--define-color)';
                default:
                    return '#999';
            }
        }
        
        // Get node group based on file extension
        function getNodeGroup(path) {
            const ext = path.split('.').pop().toLowerCase();
            switch (ext) {
                case 'js':
                    return 1;
                case 'jsx':
                    return 1;
                case 'ts':
                    return 2;
                case 'tsx':
                    return 2;
                case 'css':
                    return 3;
                case 'html':
                    return 4;
                case 'json':
                    return 5;
                default:
                    return 0;
            }
        }
        
        // Show tooltip with node details
        function showNodeTooltip(event, d) {
            const relatedDeps = dependencies.filter(dep => 
                dep.source === d.id || dep.target === d.id
            );
            
            // Group dependencies by type
            const grouped = {};
            relatedDeps.forEach(dep => {
                const type = dep.type;
                if (!grouped[type]) grouped[type] = [];
                
                if (dep.source === d.id) {
                    grouped[type].push({
                        direction: 'outgoing',
                        node: dep.target,
                        label: dep.label
                    });
                } else {
                    grouped[type].push({
                        direction: 'incoming',
                        node: dep.source,
                        label: dep.label
                    });
                }
            });
            
            // Build tooltip content
            let content = `<div><strong>${d.name}</strong></div>`;
            content += `<div class="text-muted small">${d.id}</div>`;
            content += `<hr>`;
            
            // Add dependency sections
            for (const type in grouped) {
                const typeName = type.charAt(0).toUpperCase() + type.slice(1);
                content += `<div><strong>${typeName} (${grouped[type].length}):</strong></div>`;
                
                // Limit to top 5 for each type to prevent huge tooltips
                const limited = grouped[type].slice(0, 5);
                limited.forEach(dep => {
                    const nodeName = dep.node.split('/').pop();
                    const direction = dep.direction === 'outgoing' ? '→' : '←';
                    content += `<div class="small">${direction} ${nodeName} (${dep.label})</div>`;
                });
                
                if (grouped[type].length > 5) {
                    content += `<div class="small text-muted">...and ${grouped[type].length - 5} more</div>`;
                }
                
                content += `<hr>`;
            }
            
            // Show tooltip
            tooltip.innerHTML = content;
            tooltip.style.left = `${event.pageX + 10}px`;
            tooltip.style.top = `${event.pageY + 10}px`;
            tooltip.style.opacity = 1;
        }
        
        // Hide tooltip
        function hideTooltip() {
            tooltip.style.opacity = 0;
        }
        
        // Highlight node in graph
        function highlightNodeInGraph(nodeName) {
            // Find nodes containing the name
            const nodes = d3.selectAll('.node');
            const matchingNodes = [];
            
            nodes.each(function(d) {
                if (d.name.includes(nodeName)) {
                    matchingNodes.push(this);
                }
            });
            
            // Reset all nodes first
            nodes.attr('stroke-width', 1.5)
                .attr('r', getNodeRadius);
            
            // Highlight matching nodes
            if (matchingNodes.length > 0) {
                matchingNodes.forEach(node => {
                    d3.select(node)
                        .attr('stroke-width', 3)
                        .attr('stroke', '#f72585')
                        .attr('r', graphConfig.nodeSize * 1.5);
                });
                
                // Also highlight in tree
                const treeNodes = document.querySelectorAll('.tree-node');
                treeNodes.forEach(node => {
                    if (node.textContent.includes(nodeName)) {
                        node.style.backgroundColor = 'rgba(247, 37, 133, 0.2)';
                    } else {
                        node.style.backgroundColor = '';
                    }
                });
            }
        }
        
        // Drag handlers for nodes
        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragging(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        // Center the graph visualization
        function centerGraph() {
            const svg = d3.select('#network-graph').select('svg');
            
            svg.transition().duration(750).call(
                zoomBehavior.transform,
                d3.zoomIdentity.translate(
                    networkGraph.clientWidth / 2,
                    networkGraph.clientHeight / 2
                ).scale(1)
            );
        }
        
        // Zoom in
        function zoomIn() {
            const svg = d3.select('#network-graph').select('svg');
            svg.transition().duration(300).call(
                zoomBehavior.scaleBy, 
                1.3
            );
        }
        
        // Zoom out
        function zoomOut() {
            const svg = d3.select('#network-graph').select('svg');
            svg.transition().duration(300).call(
                zoomBehavior.scaleBy, 
                0.7
            );
        }
        
        // Export dependencies to CSV
        function exportDependencies() {
            // Convert dependencies to CSV format
            const csvData = [
                ['Source', 'Target', 'Type', 'Relationship']
            ];
            
            dependencies.forEach(dep => {
                csvData.push([
                    dep.source,
                    dep.target,
                    dep.type,
                    dep.label
                ]);
            });
            
            // Generate CSV content
            const csvContent = Papa.unparse(csvData);
            
            // Create blob and download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `codebase-dependencies-${selectedFolder}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Initialize the application when the page loads
        window.addEventListener('load', init);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (simulation) {
                simulation
                    .force('center', d3.forceCenter(
                        networkGraph.clientWidth / 2,
                        networkGraph.clientHeight / 2
                    ))
                    .restart();
            }
        });
    </script>
</body>
</html>
